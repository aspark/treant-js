{"version":3,"sources":["Treant.js"],"names":["$","UTIL","inheritAttrs","applyTo","applyFrom","attr","hasOwnProperty","Object","this","createMerge","obj1","obj2","newObj","cloneObj","extend","Array","prototype","unshift","apply","arguments","obj","res","constructor","key","addEvent","el","eventType","handler","on","addEventListener","attachEvent","findEl","selector","raw","parentEl","document","$element","get","charAt","getElementById","substring","oElements","getElementsByClassName","length","Error","getOuterHeight","element","getBoundingClientRect","height","Math","ceil","outerHeight","clientHeight","getStyle","getOuterWidth","width","outerWidth","clientWidth","strCssRule","asInt","strValue","defaultView","getComputedStyle","getPropertyValue","currentStyle","replace","strMatch","p1","toUpperCase","parseFloat","addClass","cssClass","hasClass","classList","add","className","my_class","indexOf","toggleClass","cls","remove","setDimensions","style","ImageLoader","reset","loading","processNode","node","aImages","nodeDOM","getElementsByTagName","i","create","removeAll","img_src","splice","image","imgTrigger","self","source","offsetWidth","offsetHeight","src","push","complete","Date","getTime","isNotLoading","TreeStore","store","createTree","jsonConfig","nNewTreeId","Tree","treeId","destroy","tree","_R","draw_area","drawArea","firstChild","removeChild","classes","split","classes_to_stay","overflowY","overflowX","join","initJsonConfig","initTreeId","id","CONFIG","chart","container","innerHTML","imageLoader","nodeDB","NodeDB","nodeStructure","connectionStore","loaded","Raphael","reload","redraw","getNodeDb","addNode","parentTreeNode","nodeDefinition","callback","onBeforeAddNode","oNewNode","createNode","parent","level","createGeometry","createSwitchGeometry","positionTree","onAfterAddNode","root","rootOrientation","resetLevelData","firstWalk","secondWalk","positionNodes","animateOnInit","setTimeout","toggleCollapse","animateOnInitDelay","toString","call","onTreeLoaded","prelim","modifier","setNeighbors","calcLevelDim","leftSibling","childrenCount","maxDepth","size","siblingSeparation","n","childAt","midPoint","childrenCenter","apportion","stackParent","stackChildren","connStyle","stackIndent","stackParentId","firstChildLeftNeighbor","leftNeighbor","compareDepth","depthToStop","modifierSumRight","modifierSumLeft","leftAncestor","rightAncestor","undefined","totalGap","subTeeSeparation","subtreeAux","numSubtrees","subtreeMoveAux","singleGap","leftMost","X","Y","levelHeight","nodesizeTmp","xTmp","yTmp","align","nodeAlign","orinet","levelMaxDim","pseudo","swapTmp","hideRootNode","levelSeparation","rightSibling","treeSize","x","getMinMaxCoord","y","treeWidth","max","min","treeHeight","treeCenter","handleOverflow","len","containerCenter","deltaX","deltaY","negOffsetX","abs","negOffsetY","db","onBeforePositionNode","onAfterPositionNode","padding","collapsedParent","hidePoint","connectorPoint","hide","positioned","show","left","top","drawLineThrough","drawLineThroughMe","setConnectionToParent","viewWidth","viewHeight","setSize","scrollbar","jq_drawArea","find","css","perfectScrollbar","mainContainer","wrapInner","treeNode","connLine","stacked","pathString","getPointPathString","getPathString","animatePath","path","connector","hidden","animate","animation","connectorsSpeed","connectorsAnimation","from_node","to_node","startPoint","endPoint","orientation","connType","type","P1","P2","stackPoint","sp","p2","ep","pm","helpPoint","indent","leftNeighborId","lastNodeOnLevel","rightNeighborId","iterateChildren","parentId","newNode","children","childrenDropLevel","stack","hasGrandChildren","collapsed","createGeometries","nodeId","walk","onBeforeCreateNode","TreeNode","position","floor","parseInt","dim","MinMax","maxTest","minTest","meta","link","connectors","collapsable","textPropertyName","text","nodeInnerHTML","nodeHTMLclass","HTMLclass","nodeHTMLid","HTMLid","getTree","getTreeConfig","getTreeNodeDb","lookupNode","dbGet","index","lastChild","rightNeighbor","first","last","depth","leftmostDescendant","orient","point","pathStringThrough","lineThroughMe","line_style","addSwitchEvent","nodeSwitch","e","preventDefault","onBeforeClickCollapseSwitch","onAfterClickCollapseSwitch","collapse","expand","oTree","inAnimation","onToggleCollapseFinished","nodeSpeed","collapse_to_point","bCurrentState","overflow","config","oNewState","opacity","visibility","nodeAnimation","transition","transitionProperty","new_path","hideConnector","oPath","showConnector","buildNodeFromText","ele","appendChild","createElement","textElement","href","createTextNode","startsWith","setAttribute","target","val","buildNodeFromHtml","elem","cloneNode","onClickNode","levelClassName","data","treenode","onCreateNode","nodeEl","nodeSwitchEl","onCreateNodeCollapseSwitch","stroke","treeNodeDom","switchDom","newTreeNode","nodeDbIndex","bIsCollapsed","event","rootTreeNode","JSONconfig","make","configArray","jsonStructure","_json_id","findChildren","nodes","parents","pop","findNode","getID","childrenLen","found","Treant","jQuery","window"],"mappings":"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","file":"Treant.min.js","sourcesContent":["/*\r\n * Treant-js\r\n *\r\n * (c) 2013 Fran Peručić\r\n * Treant-js may be freely distributed under the MIT license.\r\n * For all details and documentation:\r\n * http://fperucic.github.io/treant-js\r\n *\r\n * Treant is an open-source JavaScipt library for visualization of tree diagrams.\r\n * It implements the node positioning algorithm of John Q. Walker II \"Positioning nodes for General Trees\".\r\n *\r\n * References:\r\n * Emilio Cortegoso Lobato: ECOTree.js v1.0 (October 26th, 2006)\r\n *\r\n * Contributors:\r\n * Fran Peručić, https://github.com/fperucic\r\n * Dave Goodchild, https://github.com/dlgoodchild\r\n */\r\n\r\n;( function() {\r\n\t\r\n\t\tvar $ = null;\r\n\t\r\n\t\tvar UTIL = {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Directly updates, recursively/deeply, the first object with all properties in the second object\r\n\t\t\t * @param {object} applyTo\r\n\t\t\t * @param {object} applyFrom\r\n\t\t\t * @return {object}\r\n\t\t\t */\r\n\t\t\tinheritAttrs: function( applyTo, applyFrom ) {\r\n\t\t\t\tfor ( var attr in applyFrom ) {\r\n\t\t\t\t\tif ( applyFrom.hasOwnProperty( attr ) ) {\r\n\t\t\t\t\t\tif ( ( applyTo[attr] instanceof Object && applyFrom[attr] instanceof Object ) && ( typeof applyFrom[attr] !== 'function' ) ) {\r\n\t\t\t\t\t\t\tthis.inheritAttrs( applyTo[attr], applyFrom[attr] );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tapplyTo[attr] = applyFrom[attr];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn applyTo;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Returns a new object by merging the two supplied objects\r\n\t\t\t * @param {object} obj1\r\n\t\t\t * @param {object} obj2\r\n\t\t\t * @returns {object}\r\n\t\t\t */\r\n\t\t\tcreateMerge: function( obj1, obj2 ) {\r\n\t\t\t\tvar newObj = {};\r\n\t\t\t\tif ( obj1 ) {\r\n\t\t\t\t\tthis.inheritAttrs( newObj, this.cloneObj( obj1 ) );\r\n\t\t\t\t}\r\n\t\t\t\tif ( obj2 ) {\r\n\t\t\t\t\tthis.inheritAttrs( newObj, obj2 );\r\n\t\t\t\t}\r\n\t\t\t\treturn newObj;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Takes any number of arguments\r\n\t\t\t * @returns {*}\r\n\t\t\t */\r\n\t\t\textend: function() {\r\n\t\t\t\tif ( $ ) {\r\n\t\t\t\t\tArray.prototype.unshift.apply( arguments, [true, {}] );\r\n\t\t\t\t\treturn $.extend.apply( $, arguments );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn UTIL.createMerge.apply( this, arguments );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {object} obj\r\n\t\t\t * @returns {*}\r\n\t\t\t */\r\n\t\t\tcloneObj: function ( obj ) {\r\n\t\t\t\tif ( Object( obj ) !== obj ) {\r\n\t\t\t\t\treturn obj;\r\n\t\t\t\t}\r\n\t\t\t\tvar res = new obj.constructor();\r\n\t\t\t\tfor ( var key in obj ) {\r\n\t\t\t\t\tif ( obj.hasOwnProperty(key) ) {\r\n\t\t\t\t\t\tres[key] = this.cloneObj(obj[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn res;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {Element} el\r\n\t\t\t * @param {string} eventType\r\n\t\t\t * @param {function} handler\r\n\t\t\t */\r\n\t\t\taddEvent: function( el, eventType, handler ) {\r\n\t\t\t\tif ( $ ) {\r\n\t\t\t\t\t$( el ).on( eventType+'.treant', handler );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( el.addEventListener ) { // DOM Level 2 browsers\r\n\t\t\t\t\tel.addEventListener( eventType, handler, false );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( el.attachEvent ) { // IE <= 8\r\n\t\t\t\t\tel.attachEvent( 'on' + eventType, handler );\r\n\t\t\t\t}\r\n\t\t\t\telse { // ancient browsers\r\n\t\t\t\t\tel['on' + eventType] = handler;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {string} selector\r\n\t\t\t * @param {boolean} raw\r\n\t\t\t * @param {Element} parentEl\r\n\t\t\t * @returns {Element|jQuery}\r\n\t\t\t */\r\n\t\t\tfindEl: function( selector, raw, parentEl ) {\r\n\t\t\t\tparentEl = parentEl || document;\r\n\t\r\n\t\t\t\tif ( $ ) {\r\n\t\t\t\t\tvar $element = $( selector, parentEl );\r\n\t\t\t\t\treturn ( raw? $element.get( 0 ): $element );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// todo: getElementsByName()\r\n\t\t\t\t\t// todo: getElementsByTagName()\r\n\t\t\t\t\t// todo: getElementsByTagNameNS()\r\n\t\t\t\t\tif ( selector.charAt( 0 ) == '#' ) {\r\n\t\t\t\t\t\treturn parentEl.getElementById( selector.substring( 1 ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( selector.charAt( 0 ) == '.' ) {\r\n\t\t\t\t\t\tvar oElements = parentEl.getElementsByClassName( selector.substring( 1 ) );\r\n\t\t\t\t\t\treturn ( oElements.length? oElements[0]: null );\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthrow new Error( 'Unknown container element' );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetOuterHeight: function( element ) {\r\n\t\t\t\tvar nRoundingCompensation = 1;\r\n\t\t\t\tif ( typeof element.getBoundingClientRect == 'function' ) {\r\n\t\t\t\t\treturn element.getBoundingClientRect().height;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( $ ) {\r\n\t\t\t\t\treturn Math.ceil( $( element ).outerHeight() ) + nRoundingCompensation;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn Math.ceil(\r\n\t\t\t\t\t\telement.clientHeight\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'border-top-width', true )\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'border-bottom-width', true )\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'padding-top', true )\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'padding-bottom', true )\r\n\t\t\t\t\t\t+ nRoundingCompensation\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetOuterWidth: function( element ) {\r\n\t\t\t\tvar nRoundingCompensation = 1;\r\n\t\t\t\tif ( typeof element.getBoundingClientRect == 'function' ) {\r\n\t\t\t\t\treturn element.getBoundingClientRect().width;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( $ ) {\r\n\t\t\t\t\treturn Math.ceil( $( element ).outerWidth() ) + nRoundingCompensation;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn Math.ceil(\r\n\t\t\t\t\t\telement.clientWidth\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'border-left-width', true )\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'border-right-width', true )\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'padding-left', true )\r\n\t\t\t\t\t\t+ UTIL.getStyle( element, 'padding-right', true )\r\n\t\t\t\t\t\t+ nRoundingCompensation\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetStyle: function( element, strCssRule, asInt ) {\r\n\t\t\t\tvar strValue = \"\";\r\n\t\t\t\tif ( document.defaultView && document.defaultView.getComputedStyle ) {\r\n\t\t\t\t\tstrValue = document.defaultView.getComputedStyle( element, '' ).getPropertyValue( strCssRule );\r\n\t\t\t\t}\r\n\t\t\t\telse if( element.currentStyle ) {\r\n\t\t\t\t\tstrCssRule = strCssRule.replace(/\\-(\\w)/g,\r\n\t\t\t\t\t\tfunction (strMatch, p1){\r\n\t\t\t\t\t\t\treturn p1.toUpperCase();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t\tstrValue = element.currentStyle[strCssRule];\r\n\t\t\t\t}\r\n\t\t\t\t//Number(elem.style.width.replace(/[^\\d\\.\\-]/g, ''));\r\n\t\t\t\treturn ( asInt? parseFloat( strValue ): strValue );\r\n\t\t\t},\r\n\t\r\n\t\t\taddClass: function( element, cssClass ) {\r\n\t\t\t\tif ( $ ) {\r\n\t\t\t\t\t$( element ).addClass( cssClass );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif ( !UTIL.hasClass( element, cssClass ) ) {\r\n\t\t\t\t\t\tif ( element.classList ) {\r\n\t\t\t\t\t\t\telement.classList.add( cssClass );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\telement.className += \" \"+cssClass;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\thasClass: function(element, my_class) {\r\n\t\t\t\treturn (\" \" + element.className + \" \").replace(/[\\n\\t]/g, \" \").indexOf(\" \"+my_class+\" \") > -1;\r\n\t\t\t},\r\n\t\r\n\t\t\ttoggleClass: function ( element, cls, apply ) {\r\n\t\t\t\tif ( $ ) {\r\n\t\t\t\t\t$( element ).toggleClass( cls, apply );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif ( apply ) {\r\n\t\t\t\t\t\t//element.className += \" \"+cls;\r\n\t\t\t\t\t\telement.classList.add( cls );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\telement.classList.remove( cls );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tsetDimensions: function( element, width, height ) {\r\n\t\t\t\tif ( $ ) {\r\n\t\t\t\t\t$( element ).width( width ).height( height );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\telement.style.width = width+'px';\r\n\t\t\t\t\telement.style.height = height+'px';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * ImageLoader is used for determining if all the images from the Tree are loaded.\r\n\t\t * Node size (width, height) can be correctly determined only when all inner images are loaded\r\n\t\t */\r\n\t\tvar ImageLoader = function() {\r\n\t\t\tthis.reset();\r\n\t\t};\r\n\t\r\n\t\tImageLoader.prototype = {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {ImageLoader}\r\n\t\t\t */\r\n\t\t\treset: function() {\r\n\t\t\t\tthis.loading = [];\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {TreeNode} node\r\n\t\t\t * @returns {ImageLoader}\r\n\t\t\t */\r\n\t\t\tprocessNode: function( node ) {\r\n\t\t\t\tvar aImages = node.nodeDOM.getElementsByTagName( 'img' );\r\n\t\r\n\t\t\t\tvar i =\taImages.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tthis.create( node, aImages[i] );\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {ImageLoader}\r\n\t\t\t */\r\n\t\t\tremoveAll: function( img_src ) {\r\n\t\t\t\tvar i = this.loading.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tif ( this.loading[i] === img_src ) {\r\n\t\t\t\t\t\tthis.loading.splice( i, 1 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {TreeNode} node\r\n\t\t\t * @param {Element} image\r\n\t\t\t * @returns {*}\r\n\t\t\t */\r\n\t\t\tcreate: function ( node, image ) {\r\n\t\t\t\tvar self = this, source = image.src;\r\n\t\r\n\t\t\t\tfunction imgTrigger() {\r\n\t\t\t\t\tself.removeAll( source );\r\n\t\t\t\t\tnode.width = node.nodeDOM.offsetWidth;\r\n\t\t\t\t\tnode.height = node.nodeDOM.offsetHeight;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( image.src.indexOf( 'data:' ) !== 0 ) {\r\n\t\t\t\t\tthis.loading.push( source );\r\n\t\r\n\t\t\t\t\tif ( image.complete ) {\r\n\t\t\t\t\t\treturn imgTrigger();\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tUTIL.addEvent( image, 'load', imgTrigger );\r\n\t\t\t\t\tUTIL.addEvent( image, 'error', imgTrigger ); // handle broken url-s\r\n\t\r\n\t\t\t\t\t// load event is not fired for cached images, force the load event\r\n\t\t\t\t\timage.src += ( ( image.src.indexOf( '?' ) > 0)? '&': '?' ) + new Date().getTime();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\timgTrigger();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {boolean}\r\n\t\t\t */\r\n\t\t\tisNotLoading: function() {\r\n\t\t\t\treturn ( this.loading.length === 0 );\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Class: TreeStore\r\n\t\t * TreeStore is used for holding initialized Tree objects\r\n\t\t * \tIts purpose is to avoid global variables and enable multiple Trees on the page.\r\n\t\t */\r\n\t\tvar TreeStore = {\r\n\t\r\n\t\t\tstore: [],\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {object} jsonConfig\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tcreateTree: function( jsonConfig ) {\r\n\t\t\t\tvar nNewTreeId = this.store.length;\r\n\t\t\t\tthis.store.push( new Tree( jsonConfig, nNewTreeId ) );\r\n\t\t\t\treturn this.get( nNewTreeId );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {number} treeId\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tget: function ( treeId ) {\r\n\t\t\t\treturn this.store[treeId];\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {number} treeId\r\n\t\t\t * @returns {TreeStore}\r\n\t\t\t */\r\n\t\t\tdestroy: function( treeId ) {\r\n\t\t\t\tvar tree = this.get( treeId );\r\n\t\t\t\tif ( tree ) {\r\n\t\t\t\t\ttree._R.remove();\r\n\t\t\t\t\tvar draw_area = tree.drawArea;\r\n\t\r\n\t\t\t\t\twhile ( draw_area.firstChild ) {\r\n\t\t\t\t\t\tdraw_area.removeChild( draw_area.firstChild );\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar classes = draw_area.className.split(' '),\r\n\t\t\t\t\t\tclasses_to_stay = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < classes.length; i++ ) {\r\n\t\t\t\t\t\tvar cls = classes[i];\r\n\t\t\t\t\t\tif ( cls != 'Treant' && cls != 'Treant-loaded' ) {\r\n\t\t\t\t\t\t\tclasses_to_stay.push(cls);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdraw_area.style.overflowY = '';\r\n\t\t\t\t\tdraw_area.style.overflowX = '';\r\n\t\t\t\t\tdraw_area.className = classes_to_stay.join(' ');\r\n\t\r\n\t\t\t\t\tthis.store[treeId] = null;\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Tree constructor.\r\n\t\t * @param {object} jsonConfig\r\n\t\t * @param {number} treeId\r\n\t\t * @constructor\r\n\t\t */\r\n\t\tvar Tree = function (jsonConfig, treeId ) {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {object} jsonConfig\r\n\t\t\t * @param {number} treeId\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tthis.reset = function( jsonConfig, treeId ) {\r\n\t\t\t\tthis.initJsonConfig = jsonConfig;\r\n\t\t\t\tthis.initTreeId = treeId;\r\n\t\r\n\t\t\t\tthis.id = treeId;\r\n\t\r\n\t\t\t\tthis.CONFIG = UTIL.extend( Tree.CONFIG, jsonConfig.chart );\r\n\t\t\t\tthis.drawArea = UTIL.findEl( this.CONFIG.container, true );\r\n\t\t\t\tif ( !this.drawArea ) {\r\n\t\t\t\t\tthrow new Error( 'Failed to find element by selector \"'+this.CONFIG.container+'\"' );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tUTIL.addClass( this.drawArea, 'Treant' );\r\n\t\r\n\t\t\t\t// kill of any child elements that may be there\r\n\t\t\t\tthis.drawArea.innerHTML = '';\r\n\t\r\n\t\t\t\tthis.imageLoader = new ImageLoader();\r\n\t\r\n\t\t\t\tthis.nodeDB = new NodeDB( jsonConfig.nodeStructure, this );\r\n\t\r\n\t\t\t\t// key store for storing reference to node connectors,\r\n\t\t\t\t// key = nodeId where the connector ends\r\n\t\t\t\tthis.connectionStore = {};\r\n\t\r\n\t\t\t\tthis.loaded = false;\r\n\t\r\n\t\t\t\tthis._R = new Raphael( this.drawArea, 100, 100 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tthis.reload = function() {\r\n\t\t\t\tthis.reset( this.initJsonConfig, this.initTreeId ).redraw();\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\r\n\t\t\tthis.reset( jsonConfig, treeId );\r\n\t\t};\r\n\t\r\n\t\tTree.prototype = {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {NodeDB}\r\n\t\t\t */\r\n\t\t\tgetNodeDb: function() {\r\n\t\t\t\treturn this.nodeDB;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {TreeNode} parentTreeNode\r\n\t\t\t * @param {object} nodeDefinition\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\taddNode: function( parentTreeNode, nodeDefinition ) {\r\n\t\t\t\tvar dbEntry = this.nodeDB.get( parentTreeNode.id );\r\n\t\r\n\t\t\t\tthis.CONFIG.callback.onBeforeAddNode.apply( this, [parentTreeNode, nodeDefinition] );\r\n\t\r\n\t\t\t\tvar oNewNode = this.nodeDB.createNode( nodeDefinition, parentTreeNode.id, this, null, this.parent().level+1 );\r\n\t\t\t\toNewNode.createGeometry( this );\r\n\t\r\n\t\t\t\toNewNode.parent().createSwitchGeometry( this );\r\n\t\r\n\t\t\t\tthis.positionTree();\r\n\t\r\n\t\t\t\tthis.CONFIG.callback.onAfterAddNode.apply( this, [oNewNode, parentTreeNode, nodeDefinition] );\r\n\t\r\n\t\t\t\treturn oNewNode;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tredraw: function() {\r\n\t\t\t\tthis.positionTree();\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {function} callback\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tpositionTree: function( callback ) {\r\n\t\t\t\tvar self = this;\r\n\t\r\n\t\t\t\tif ( this.imageLoader.isNotLoading() ) {\r\n\t\t\t\t\tvar root = this.root(),\r\n\t\t\t\t\t\torient = this.CONFIG.rootOrientation;\r\n\t\r\n\t\t\t\t\tthis.resetLevelData();\r\n\t\r\n\t\t\t\t\tthis.firstWalk( root, 0 );\r\n\t\t\t\t\tthis.secondWalk( root, 0, 0, 0 );\r\n\t\r\n\t\t\t\t\tthis.positionNodes();\r\n\t\r\n\t\t\t\t\tif ( this.CONFIG.animateOnInit ) {\r\n\t\t\t\t\t\tsetTimeout(\r\n\t\t\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\t\t\troot.toggleCollapse();\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tthis.CONFIG.animateOnInitDelay\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( !this.loaded ) {\r\n\t\t\t\t\t\tUTIL.addClass( this.drawArea, 'Treant-loaded' ); // nodes are hidden until .loaded class is added\r\n\t\t\t\t\t\tif ( Object.prototype.toString.call( callback ) === \"[object Function]\" ) {\r\n\t\t\t\t\t\t\tcallback( self );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tself.CONFIG.callback.onTreeLoaded.apply( self, [root] );\r\n\t\t\t\t\t\tthis.loaded = true;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tsetTimeout(\r\n\t\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\t\tself.positionTree( callback );\r\n\t\t\t\t\t\t}, 10\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * In a first post-order walk, every node of the tree is assigned a preliminary\r\n\t\t\t * x-coordinate (held in field node->prelim).\r\n\t\t\t * In addition, internal nodes are given modifiers, which will be used to move their\r\n\t\t\t * children to the right (held in field node->modifier).\r\n\t\t\t * @param {TreeNode} node\r\n\t\t\t * @param {number} level\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tfirstWalk: function( node, level ) {\r\n\t\t\t\tnode.prelim = null;\r\n\t\t\t\tnode.modifier = null;\r\n\t\r\n\t\t\t\tthis.setNeighbors( node, level );\r\n\t\t\t\tthis.calcLevelDim( node, level );\r\n\t\r\n\t\t\t\tvar leftSibling = node.leftSibling();\r\n\t\r\n\t\t\t\tif ( node.childrenCount() === 0 || level == this.CONFIG.maxDepth ) {\r\n\t\t\t\t\t// set preliminary x-coordinate\r\n\t\t\t\t\tif ( leftSibling ) {\r\n\t\t\t\t\t\tnode.prelim = leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tnode.prelim = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t//node is not a leaf,  firstWalk for each child\r\n\t\t\t\t\tfor ( var i = 0, n = node.childrenCount(); i < n; i++ ) {\r\n\t\t\t\t\t\tthis.firstWalk(node.childAt(i), level + 1);\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar midPoint = node.childrenCenter() - node.size() / 2;\r\n\t\r\n\t\t\t\t\tif ( leftSibling ) {\r\n\t\t\t\t\t\tnode.prelim = leftSibling.prelim + leftSibling.size() + this.CONFIG.siblingSeparation;\r\n\t\t\t\t\t\tnode.modifier = node.prelim - midPoint;\r\n\t\t\t\t\t\tthis.apportion( node, level );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tnode.prelim = midPoint;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// handle stacked children positioning\r\n\t\t\t\t\tif ( node.stackParent ) { // handle the parent of stacked children\r\n\t\t\t\t\t\tnode.modifier += this.nodeDB.get( node.stackChildren[0] ).size()/2 + node.connStyle.stackIndent;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( node.stackParentId ) { // handle stacked children\r\n\t\t\t\t\t\tnode.prelim = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/*\r\n\t\t\t * Clean up the positioning of small sibling subtrees.\r\n\t\t\t * Subtrees of a node are formed independently and\r\n\t\t\t * placed as close together as possible. By requiring\r\n\t\t\t * that the subtrees be rigid at the time they are put\r\n\t\t\t * together, we avoid the undesirable effects that can\r\n\t\t\t * accrue from positioning nodes rather than subtrees.\r\n\t\t\t */\r\n\t\t\tapportion: function (node, level) {\r\n\t\t\t\tvar firstChild\t\t\t\t= node.firstChild(),\r\n\t\t\t\t\tfirstChildLeftNeighbor\t= firstChild.leftNeighbor(),\r\n\t\t\t\t\tcompareDepth\t\t\t= 1,\r\n\t\t\t\t\tdepthToStop\t\t\t\t= this.CONFIG.maxDepth - level;\r\n\t\r\n\t\t\t\twhile( firstChild && firstChildLeftNeighbor && compareDepth <= depthToStop ) {\r\n\t\t\t\t\t// calculate the position of the firstChild, according to the position of firstChildLeftNeighbor\r\n\t\r\n\t\t\t\t\tvar modifierSumRight\t= 0,\r\n\t\t\t\t\t\tmodifierSumLeft\t\t= 0,\r\n\t\t\t\t\t\tleftAncestor\t\t= firstChildLeftNeighbor,\r\n\t\t\t\t\t\trightAncestor\t\t= firstChild;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < compareDepth; i++ ) {\r\n\t\t\t\t\t\tleftAncestor = leftAncestor.parent();\r\n\t\t\t\t\t\trightAncestor = rightAncestor.parent();\r\n\t\t\t\t\t\tmodifierSumLeft += leftAncestor.modifier;\r\n\t\t\t\t\t\tmodifierSumRight += rightAncestor.modifier;\r\n\t\r\n\t\t\t\t\t\t// all the stacked children are oriented towards right so use right variables\r\n\t\t\t\t\t\tif ( rightAncestor.stackParent !== undefined ) {\r\n\t\t\t\t\t\t\tmodifierSumRight += rightAncestor.size() / 2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// find the gap between two trees and apply it to subTrees\r\n\t\t\t\t\t// and mathing smaller gaps to smaller subtrees\r\n\t\r\n\t\t\t\t\tvar totalGap = (firstChildLeftNeighbor.prelim + modifierSumLeft + firstChildLeftNeighbor.size() + this.CONFIG.subTeeSeparation) - (firstChild.prelim + modifierSumRight );\r\n\t\r\n\t\t\t\t\tif ( totalGap > 0 ) {\r\n\t\t\t\t\t\tvar subtreeAux = node,\r\n\t\t\t\t\t\t\tnumSubtrees = 0;\r\n\t\r\n\t\t\t\t\t\t// count all the subtrees in the LeftSibling\r\n\t\t\t\t\t\twhile ( subtreeAux && subtreeAux.id != leftAncestor.id ) {\r\n\t\t\t\t\t\t\tsubtreeAux = subtreeAux.leftSibling();\r\n\t\t\t\t\t\t\tnumSubtrees++;\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( subtreeAux ) {\r\n\t\t\t\t\t\t\tvar subtreeMoveAux = node,\r\n\t\t\t\t\t\t\t\tsingleGap = totalGap / numSubtrees;\r\n\t\r\n\t\t\t\t\t\t\twhile ( subtreeMoveAux.id != leftAncestor.id ) {\r\n\t\t\t\t\t\t\t\tsubtreeMoveAux.prelim += totalGap;\r\n\t\t\t\t\t\t\t\tsubtreeMoveAux.modifier += totalGap;\r\n\t\r\n\t\t\t\t\t\t\t\ttotalGap -= singleGap;\r\n\t\t\t\t\t\t\t\tsubtreeMoveAux = subtreeMoveAux.leftSibling();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tcompareDepth++;\r\n\t\r\n\t\t\t\t\tfirstChild = ( firstChild.childrenCount() === 0 )?\r\n\t\t\t\t\t\tnode.leftMost(0, compareDepth):\r\n\t\t\t\t\t\tfirstChild = firstChild.firstChild();\r\n\t\r\n\t\t\t\t\tif ( firstChild ) {\r\n\t\t\t\t\t\tfirstChildLeftNeighbor = firstChild.leftNeighbor();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/*\r\n\t\t\t * During a second pre-order walk, each node is given a\r\n\t\t\t * final x-coordinate by summing its preliminary\r\n\t\t\t * x-coordinate and the modifiers of all the node's\r\n\t\t\t * ancestors.  The y-coordinate depends on the height of\r\n\t\t\t * the tree.  (The roles of x and y are reversed for\r\n\t\t\t * RootOrientations of EAST or WEST.)\r\n\t\t\t */\r\n\t\t\tsecondWalk: function( node, level, X, Y ) {\r\n\t\t\t\tif ( level <= this.CONFIG.maxDepth ) {\r\n\t\t\t\t\tvar xTmp = node.prelim + X,\r\n\t\t\t\t\t\tyTmp = Y, align = this.CONFIG.nodeAlign,\r\n\t\t\t\t\t\torinet = this.CONFIG.rootOrientation,\r\n\t\t\t\t\t\tlevelHeight, nodesizeTmp;\r\n\t\r\n\t\t\t\t\tif (orinet == 'NORTH' || orinet == 'SOUTH') {\r\n\t\t\t\t\t\tlevelHeight = this.levelMaxDim[level].height;\r\n\t\t\t\t\t\tnodesizeTmp = node.height;\r\n\t\t\t\t\t\tif (node.pseudo) {\r\n\t\t\t\t\t\t\tnode.height = levelHeight;\r\n\t\t\t\t\t\t} // assign a new size to pseudo nodes\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (orinet == 'WEST' || orinet == 'EAST') {\r\n\t\t\t\t\t\tlevelHeight = this.levelMaxDim[level].width;\r\n\t\t\t\t\t\tnodesizeTmp = node.width;\r\n\t\t\t\t\t\tif (node.pseudo) {\r\n\t\t\t\t\t\t\tnode.width = levelHeight;\r\n\t\t\t\t\t\t} // assign a new size to pseudo nodes\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnode.X = xTmp;\r\n\t\r\n\t\t\t\t\tif (node.pseudo) { // pseudo nodes need to be properly aligned, otherwise position is not correct in some examples\r\n\t\t\t\t\t\tif (orinet == 'NORTH' || orinet == 'WEST') {\r\n\t\t\t\t\t\t\tnode.Y = yTmp; // align \"BOTTOM\"\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (orinet == 'SOUTH' || orinet == 'EAST') {\r\n\t\t\t\t\t\t\tnode.Y = (yTmp + (levelHeight - nodesizeTmp)); // align \"TOP\"\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnode.Y = ( align == 'CENTER' ) ? (yTmp + (levelHeight - nodesizeTmp) / 2) :\r\n\t\t\t\t\t\t\t( align == 'TOP' )\t? (yTmp + (levelHeight - nodesizeTmp)) :\r\n\t\t\t\t\t\t\t\tyTmp;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( orinet == 'WEST' || orinet == 'EAST' ) {\r\n\t\t\t\t\t\tvar swapTmp = node.X;\r\n\t\t\t\t\t\tnode.X = node.Y;\r\n\t\t\t\t\t\tnode.Y = swapTmp;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif (orinet == 'SOUTH' ) {\r\n\t\t\t\t\t\tnode.Y = -node.Y - nodesizeTmp;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( orinet == 'EAST' ) {\r\n\t\t\t\t\t\tnode.X = -node.X - nodesizeTmp;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( node.childrenCount() !== 0 ) {\r\n\t\t\t\t\t\tif ( node.id === 0 && this.CONFIG.hideRootNode ) {\r\n\t\t\t\t\t\t\t// ako je root node Hiden onda nemoj njegovu dijecu pomaknut po Y osi za Level separation, neka ona budu na vrhu\r\n\t\t\t\t\t\t\tthis.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.secondWalk(node.firstChild(), level + 1, X + node.modifier, Y + levelHeight + this.CONFIG.levelSeparation);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( node.rightSibling() ) {\r\n\t\t\t\t\t\tthis.secondWalk( node.rightSibling(), level, X, Y );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * position all the nodes, center the tree in center of its container\r\n\t\t\t * 0,0 coordinate is in the upper left corner\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tpositionNodes: function() {\r\n\t\t\t\tvar self = this,\r\n\t\t\t\t\ttreeSize = {\r\n\t\t\t\t\t\tx: self.nodeDB.getMinMaxCoord('X', null, null),\r\n\t\t\t\t\t\ty: self.nodeDB.getMinMaxCoord('Y', null, null)\r\n\t\t\t\t\t},\r\n\t\r\n\t\t\t\t\ttreeWidth = treeSize.x.max - treeSize.x.min,\r\n\t\t\t\t\ttreeHeight = treeSize.y.max - treeSize.y.min,\r\n\t\r\n\t\t\t\t\ttreeCenter = {\r\n\t\t\t\t\t\tx: treeSize.x.max - treeWidth/2,\r\n\t\t\t\t\t\ty: treeSize.y.max - treeHeight/2\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\tthis.handleOverflow(treeWidth, treeHeight);\r\n\t\r\n\t\t\t\tvar\r\n\t\t\t\t\tcontainerCenter = {\r\n\t\t\t\t\t\tx: self.drawArea.clientWidth/2,\r\n\t\t\t\t\t\ty: self.drawArea.clientHeight/2\r\n\t\t\t\t\t},\r\n\t\r\n\t\t\t\t\tdeltaX = containerCenter.x - treeCenter.x,\r\n\t\t\t\t\tdeltaY = containerCenter.y - treeCenter.y,\r\n\t\r\n\t\t\t\t\t// all nodes must have positive X or Y coordinates, handle this with offsets\r\n\t\t\t\t\tnegOffsetX = ((treeSize.x.min + deltaX) <= 0) ? Math.abs(treeSize.x.min) : 0,\r\n\t\t\t\t\tnegOffsetY = ((treeSize.y.min + deltaY) <= 0) ? Math.abs(treeSize.y.min) : 0,\r\n\t\t\t\t\ti, len, node;\r\n\t\r\n\t\t\t\t// position all the nodes\r\n\t\t\t\tfor ( i = 0, len = this.nodeDB.db.length; i < len; i++ ) {\r\n\t\r\n\t\t\t\t\tnode = this.nodeDB.get(i);\r\n\t\r\n\t\t\t\t\tself.CONFIG.callback.onBeforePositionNode.apply( self, [node, i, containerCenter, treeCenter] );\r\n\t\r\n\t\t\t\t\tif ( node.id === 0 && this.CONFIG.hideRootNode ) {\r\n\t\t\t\t\t\tself.CONFIG.callback.onAfterPositionNode.apply( self, [node, i, containerCenter, treeCenter] );\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// if the tree is smaller than the draw area, then center the tree within drawing area\r\n\t\t\t\t\tnode.X += negOffsetX + ((treeWidth < this.drawArea.clientWidth) ? deltaX : this.CONFIG.padding);\r\n\t\t\t\t\tnode.Y += negOffsetY + ((treeHeight < this.drawArea.clientHeight) ? deltaY : this.CONFIG.padding);\r\n\t\r\n\t\t\t\t\tvar collapsedParent = node.collapsedParent(),\r\n\t\t\t\t\t\thidePoint = null;\r\n\t\r\n\t\t\t\t\tif (collapsedParent) {\r\n\t\t\t\t\t\t// position the node behind the connector point of the parent, so future animations can be visible\r\n\t\t\t\t\t\thidePoint = collapsedParent.connectorPoint( true );\r\n\t\t\t\t\t\tnode.hide(hidePoint);\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (node.positioned) {\r\n\t\t\t\t\t\t// node is already positioned,\r\n\t\t\t\t\t\tnode.show();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { // inicijalno stvaranje nodeova, postavi lokaciju\r\n\t\t\t\t\t\tnode.nodeDOM.style.left = node.X + 'px';\r\n\t\t\t\t\t\tnode.nodeDOM.style.top = node.Y + 'px';\r\n\t\t\t\t\t\tnode.positioned = true;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif (node.id !== 0 && !(node.parent().id === 0 && this.CONFIG.hideRootNode)) {\r\n\t\t\t\t\t\tthis.setConnectionToParent(node, hidePoint); // skip the root node\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (!this.CONFIG.hideRootNode && node.drawLineThrough) {\r\n\t\t\t\t\t\t// drawlinethrough is performed for for the root node also\r\n\t\t\t\t\t\tnode.drawLineThroughMe();\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tself.CONFIG.callback.onAfterPositionNode.apply( self, [node, i, containerCenter, treeCenter] );\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Create Raphael instance, (optionally set scroll bars if necessary)\r\n\t\t\t * @param {number} treeWidth\r\n\t\t\t * @param {number} treeHeight\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\thandleOverflow: function( treeWidth, treeHeight ) {\r\n\t\t\t\tvar viewWidth = (treeWidth < this.drawArea.clientWidth) ? this.drawArea.clientWidth : treeWidth + this.CONFIG.padding*2,\r\n\t\t\t\t\tviewHeight = (treeHeight < this.drawArea.clientHeight) ? this.drawArea.clientHeight : treeHeight + this.CONFIG.padding*2;\r\n\t\r\n\t\t\t\tthis._R.setSize( viewWidth, viewHeight );\r\n\t\r\n\t\t\t\tif ( this.CONFIG.scrollbar == 'resize') {\r\n\t\t\t\t\tUTIL.setDimensions( this.drawArea, viewWidth, viewHeight );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( $ == undefined || this.CONFIG.scrollbar == 'native' ) {\r\n\t\r\n\t\t\t\t\tif ( this.drawArea.clientWidth < treeWidth ) { // is overflow-x necessary\r\n\t\t\t\t\t\tthis.drawArea.style.overflowX = \"auto\";\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( this.drawArea.clientHeight < treeHeight ) { // is overflow-y necessary\r\n\t\t\t\t\t\tthis.drawArea.style.overflowY = \"auto\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Fancy scrollbar relies heavily on jQuery, so guarding with if ( $ )\r\n\t\t\t\telse if ( this.CONFIG.scrollbar == 'fancy') {\r\n\t\t\t\t\tvar jq_drawArea = $( this.drawArea );\r\n\t\t\t\t\tif (jq_drawArea.hasClass('ps-container')) { // znaci da je 'fancy' vec inicijaliziran, treba updateat\r\n\t\t\t\t\t\tjq_drawArea.find('.Treant').css({\r\n\t\t\t\t\t\t\twidth: viewWidth,\r\n\t\t\t\t\t\t\theight: viewHeight\r\n\t\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t\tjq_drawArea.perfectScrollbar('update');\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tvar mainContainer = jq_drawArea.wrapInner('<div class=\"Treant\"/>'),\r\n\t\t\t\t\t\t\tchild = mainContainer.find('.Treant');\r\n\t\r\n\t\t\t\t\t\tchild.css({\r\n\t\t\t\t\t\t\twidth: viewWidth,\r\n\t\t\t\t\t\t\theight: viewHeight\r\n\t\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t\tmainContainer.perfectScrollbar();\r\n\t\t\t\t\t}\r\n\t\t\t\t} // else this.CONFIG.scrollbar == 'None'\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {TreeNode} treeNode\r\n\t\t\t * @param {boolean} hidePoint\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tsetConnectionToParent: function( treeNode, hidePoint ) {\r\n\t\t\t\tvar stacked = treeNode.stackParentId,\r\n\t\t\t\t\tconnLine,\r\n\t\t\t\t\tparent = ( stacked? this.nodeDB.get( stacked ): treeNode.parent() ),\r\n\t\r\n\t\t\t\t\tpathString = hidePoint?\r\n\t\t\t\t\t\tthis.getPointPathString(hidePoint):\r\n\t\t\t\t\t\tthis.getPathString(parent, treeNode, stacked);\r\n\t\r\n\t\t\t\tif ( this.connectionStore[treeNode.id] ) {\r\n\t\t\t\t\t// connector already exists, update the connector geometry\r\n\t\t\t\t\tconnLine = this.connectionStore[treeNode.id];\r\n\t\t\t\t\tthis.animatePath( connLine, pathString );\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconnLine = this._R.path( pathString );\r\n\t\t\t\t\tthis.connectionStore[treeNode.id] = connLine;\r\n\t\r\n\t\t\t\t\t// don't show connector arrows por pseudo nodes\r\n\t\t\t\t\tif ( treeNode.pseudo ) {\r\n\t\t\t\t\t\tdelete parent.connStyle.style['arrow-end'];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( parent.pseudo ) {\r\n\t\t\t\t\t\tdelete parent.connStyle.style['arrow-start'];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tconnLine.attr( parent.connStyle.style );\r\n\t\r\n\t\t\t\t\tif ( treeNode.drawLineThrough || treeNode.pseudo ) {\r\n\t\t\t\t\t\ttreeNode.drawLineThroughMe( hidePoint );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttreeNode.connector = connLine;\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Create the path which is represented as a point, used for hiding the connection\r\n\t\t\t * A path with a leading \"_\" indicates the path will be hidden\r\n\t\t\t * See: http://dmitrybaranovskiy.github.io/raphael/reference.html#Paper.path\r\n\t\t\t * @param {object} hidePoint\r\n\t\t\t * @returns {string}\r\n\t\t\t */\r\n\t\t\tgetPointPathString: function( hidePoint ) {\r\n\t\t\t\treturn [\"_M\", hidePoint.x, \",\", hidePoint.y, 'L', hidePoint.x, \",\", hidePoint.y, hidePoint.x, \",\", hidePoint.y].join(' ');\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * This method relied on receiving a valid Raphael Paper.path.\r\n\t\t\t * See: http://dmitrybaranovskiy.github.io/raphael/reference.html#Paper.path\r\n\t\t\t * A pathString is typically in the format of \"M10,20L30,40\"\r\n\t\t\t * @param path\r\n\t\t\t * @param {string} pathString\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tanimatePath: function( path, pathString ) {\r\n\t\t\t\tif (path.hidden && pathString.charAt(0) !== \"_\") { // path will be shown, so show it\r\n\t\t\t\t\tpath.show();\r\n\t\t\t\t\tpath.hidden = false;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// See: http://dmitrybaranovskiy.github.io/raphael/reference.html#Element.animate\r\n\t\t\t\tpath.animate(\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tpath: pathString.charAt(0) === \"_\"?\r\n\t\t\t\t\t\t\tpathString.substring(1):\r\n\t\t\t\t\t\t\tpathString // remove the \"_\" prefix if it exists\r\n\t\t\t\t\t},\r\n\t\t\t\t\tthis.CONFIG.animation.connectorsSpeed,\r\n\t\t\t\t\tthis.CONFIG.animation.connectorsAnimation,\r\n\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\tif ( pathString.charAt(0) === \"_\" ) { // animation is hiding the path, hide it at the and of animation\r\n\t\t\t\t\t\t\tpath.hide();\r\n\t\t\t\t\t\t\tpath.hidden = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t *\r\n\t\t\t * @param {TreeNode} from_node\r\n\t\t\t * @param {TreeNode} to_node\r\n\t\t\t * @param {boolean} stacked\r\n\t\t\t * @returns {string}\r\n\t\t\t */\r\n\t\t\tgetPathString: function( from_node, to_node, stacked ) {\r\n\t\t\t\tvar startPoint = from_node.connectorPoint( true ),\r\n\t\t\t\t\tendPoint = to_node.connectorPoint( false ),\r\n\t\t\t\t\torientation = this.CONFIG.rootOrientation,\r\n\t\t\t\t\tconnType = from_node.connStyle.type,\r\n\t\t\t\t\tP1 = {}, P2 = {};\r\n\t\r\n\t\t\t\tif ( orientation == 'NORTH' || orientation == 'SOUTH' ) {\r\n\t\t\t\t\tP1.y = P2.y = (startPoint.y + endPoint.y) / 2;\r\n\t\r\n\t\t\t\t\tP1.x = startPoint.x;\r\n\t\t\t\t\tP2.x = endPoint.x;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( orientation == 'EAST' || orientation == 'WEST' ) {\r\n\t\t\t\t\tP1.x = P2.x = (startPoint.x + endPoint.x) / 2;\r\n\t\r\n\t\t\t\t\tP1.y = startPoint.y;\r\n\t\t\t\t\tP2.y = endPoint.y;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// sp, p1, pm, p2, ep == \"x,y\"\r\n\t\t\t\tvar sp = startPoint.x+','+startPoint.y, p1 = P1.x+','+P1.y, p2 = P2.x+','+P2.y, ep = endPoint.x+','+endPoint.y,\r\n\t\t\t\t\tpm = (P1.x + P2.x)/2 +','+ (P1.y + P2.y)/2, pathString, stackPoint;\r\n\t\r\n\t\t\t\tif ( stacked ) { // STACKED CHILDREN\r\n\t\r\n\t\t\t\t\tstackPoint = (orientation == 'EAST' || orientation == 'WEST')?\r\n\t\t\t\t\tendPoint.x+','+startPoint.y:\r\n\t\t\t\t\tstartPoint.x+','+endPoint.y;\r\n\t\r\n\t\t\t\t\tif ( connType == \"step\" || connType == \"straight\" ) {\r\n\t\t\t\t\t\tpathString = [\"M\", sp, 'L', stackPoint, 'L', ep];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( connType == \"curve\" || connType == \"bCurve\" ) {\r\n\t\t\t\t\t\tvar helpPoint, // used for nicer curve lines\r\n\t\t\t\t\t\t\tindent = from_node.connStyle.stackIndent;\r\n\t\r\n\t\t\t\t\t\tif ( orientation == 'NORTH' ) {\r\n\t\t\t\t\t\t\thelpPoint = (endPoint.x - indent)+','+(endPoint.y - indent);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( orientation == 'SOUTH' ) {\r\n\t\t\t\t\t\t\thelpPoint = (endPoint.x - indent)+','+(endPoint.y + indent);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( orientation == 'EAST' ) {\r\n\t\t\t\t\t\t\thelpPoint = (endPoint.x + indent) +','+startPoint.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( orientation == 'WEST' ) {\r\n\t\t\t\t\t\t\thelpPoint = (endPoint.x - indent) +','+startPoint.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpathString = [\"M\", sp, 'L', helpPoint, 'S', stackPoint, ep];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\telse {  // NORMAL CHILDREN\r\n\t\t\t\t\tif ( connType == \"step\" ) {\r\n\t\t\t\t\t\tpathString = [\"M\", sp, 'L', p1, 'L', p2, 'L', ep];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( connType == \"curve\" ) {\r\n\t\t\t\t\t\tpathString = [\"M\", sp, 'C', p1, p2, ep ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( connType == \"bCurve\" ) {\r\n\t\t\t\t\t\tpathString = [\"M\", sp, 'Q', p1, pm, 'T', ep];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (connType == \"straight\" ) {\r\n\t\t\t\t\t\tpathString = [\"M\", sp, 'L', sp, ep];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn pathString.join(\" \");\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Algorithm works from left to right, so previous processed node will be left neighbour of the next node\r\n\t\t\t * @param {TreeNode} node\r\n\t\t\t * @param {number} level\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tsetNeighbors: function( node, level ) {\r\n\t\t\t\tnode.leftNeighborId = this.lastNodeOnLevel[level];\r\n\t\t\t\tif ( node.leftNeighborId ) {\r\n\t\t\t\t\tnode.leftNeighbor().rightNeighborId = node.id;\r\n\t\t\t\t}\r\n\t\t\t\tthis.lastNodeOnLevel[level] = node.id;\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Used for calculation of height and width of a level (level dimensions)\r\n\t\t\t * @param {TreeNode} node\r\n\t\t\t * @param {number} level\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tcalcLevelDim: function( node, level ) { // root node is on level 0\r\n\t\t\t\tthis.levelMaxDim[level] = {\r\n\t\t\t\t\twidth: Math.max( this.levelMaxDim[level]? this.levelMaxDim[level].width: 0, node.width ),\r\n\t\t\t\t\theight: Math.max( this.levelMaxDim[level]? this.levelMaxDim[level].height: 0, node.height )\r\n\t\t\t\t};\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tresetLevelData: function() {\r\n\t\t\t\tthis.lastNodeOnLevel = [];\r\n\t\t\t\tthis.levelMaxDim = [];\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\troot: function() {\r\n\t\t\t\treturn this.nodeDB.get( 0 );\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * NodeDB is used for storing the nodes. Each tree has its own NodeDB.\r\n\t\t * @param {object} nodeStructure\r\n\t\t * @param {Tree} tree\r\n\t\t * @constructor\r\n\t\t */\r\n\t\tvar NodeDB = function ( nodeStructure, tree ) {\r\n\t\t\tthis.reset( nodeStructure, tree )\r\n\t\t};\r\n\t\r\n\t\tNodeDB.prototype = {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {object} nodeStructure\r\n\t\t\t * @param {Tree} tree\r\n\t\t\t * @returns {NodeDB}\r\n\t\t\t */\r\n\t\t\treset: function( nodeStructure, tree ) {\r\n\t\r\n\t\t\t\tthis.db\t= [];\r\n\t\r\n\t\t\t\tvar self = this;\r\n\t\r\n\t\t\t\t/**\r\n\t\t\t\t * @param {object} node\r\n\t\t\t\t * @param {number} parentId\r\n\t\t\t\t */\r\n\t\t\t\tfunction iterateChildren( node, parentId, level ) {\r\n\t\t\t\t\tvar newNode = self.createNode( node, parentId, tree, null, level );\r\n\t\r\n\t\t\t\t\tif ( node.children ) {//todo:change children property name  tree.CONFIG.childrenName||'children'\r\n\t\t\t\t\t\t// pseudo node is used for descending children to the next level\r\n\t\t\t\t\t\tif ( node.childrenDropLevel && node.childrenDropLevel > 0 ) {\r\n\t\t\t\t\t\t\twhile ( node.childrenDropLevel-- ) {\r\n\t\t\t\t\t\t\t\t// pseudo node needs to inherit the connection style from its parent for continuous connectors\r\n\t\t\t\t\t\t\t\tvar connStyle = UTIL.cloneObj( newNode.connStyle );\r\n\t\t\t\t\t\t\t\tnewNode = self.createNode( 'pseudo', newNode.id, tree, null, level+1 );\r\n\t\t\t\t\t\t\t\tnewNode.connStyle = connStyle;\r\n\t\t\t\t\t\t\t\tnewNode.children = [];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar stack = ( node.stackChildren && !self.hasGrandChildren( node ) )? newNode.id: null;\r\n\t\r\n\t\t\t\t\t\t// children are positioned on separate levels, one beneath the other\r\n\t\t\t\t\t\tif ( stack !== null ) {\r\n\t\t\t\t\t\t\tnewNode.stackChildren = [];\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, len = node.children.length; i < len ; i++ ) {\r\n\t\t\t\t\t\t\tif ( stack !== null ) {\r\n\t\t\t\t\t\t\t\tnewNode =  self.createNode( node.children[i], newNode.id, tree, stack, level+1 );\r\n\t\t\t\t\t\t\t\tif ( ( i + 1 ) < len ) {\r\n\t\t\t\t\t\t\t\t\t// last node cant have children\r\n\t\t\t\t\t\t\t\t\tnewNode.children = [];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\titerateChildren( node.children[i], newNode.id, level+1 );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( tree.CONFIG.animateOnInit ) {\r\n\t\t\t\t\tnodeStructure.collapsed = true;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\titerateChildren( nodeStructure, -1, 0 ); // root node\r\n\t\r\n\t\t\t\tthis.createGeometries( tree );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {Tree} tree\r\n\t\t\t * @returns {NodeDB}\r\n\t\t\t */\r\n\t\t\tcreateGeometries: function( tree ) {\r\n\t\t\t\tvar i = this.db.length;\r\n\t\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tthis.get( i ).createGeometry( tree );\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {number} nodeId\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tget: function ( nodeId ) {\r\n\t\t\t\treturn this.db[nodeId]; // get TreeNode by ID\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {function} callback\r\n\t\t\t * @returns {NodeDB}\r\n\t\t\t */\r\n\t\t\twalk: function( callback ) {\r\n\t\t\t\tvar i = this.db.length;\r\n\t\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tcallback.apply( this, [ this.get( i ) ] );\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t *\r\n\t\t\t * @param {object} nodeStructure\r\n\t\t\t * @param {number} parentId\r\n\t\t\t * @param {Tree} tree\r\n\t\t\t * @param {number} stackParentId\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tcreateNode: function( nodeStructure, parentId, tree, stackParentId, level ) {\r\n\t\t\t\tif(tree.CONFIG.callback.onBeforeCreateNode){\r\n\t\t\t\t\ttree.CONFIG.callback.onBeforeCreateNode.apply(tree, [nodeStructure]);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar node = new TreeNode( nodeStructure, this.db.length, parentId, tree, stackParentId, level );\r\n\t\r\n\t\t\t\tthis.db.push( node );\r\n\t\r\n\t\t\t\t// skip root node (0)\r\n\t\t\t\tif ( parentId >= 0 ) {\r\n\t\t\t\t\tvar parent = this.get( parentId );\r\n\t\r\n\t\t\t\t\t// todo: refactor into separate private method\r\n\t\t\t\t\tif ( nodeStructure.position ) {\r\n\t\t\t\t\t\tif ( nodeStructure.position == 'left' ) {\r\n\t\t\t\t\t\t\tparent.children.push( node.id );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( nodeStructure.position == 'right' ) {\r\n\t\t\t\t\t\t\tparent.children.splice( 0, 0, node.id );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( nodeStructure.position == 'center' ) {\r\n\t\t\t\t\t\t\tparent.children.splice( Math.floor( parent.children.length / 2 ), 0, node.id );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// edge case when there's only 1 child\r\n\t\t\t\t\t\t\tvar position = parseInt( nodeStructure.position );\r\n\t\t\t\t\t\t\tif ( parent.children.length == 1 && position > 0 ) {\r\n\t\t\t\t\t\t\t\tparent.children.splice( 0, 0, node.id );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tparent.children.splice(\r\n\t\t\t\t\t\t\t\t\tMath.max( position, parent.children.length - 1 ),\r\n\t\t\t\t\t\t\t\t\t0, node.id\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tparent.children.push( node.id );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( stackParentId ) {\r\n\t\t\t\t\tthis.get( stackParentId ).stackParent = true;\r\n\t\t\t\t\tthis.get( stackParentId ).stackChildren.push( node.id );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn node;\r\n\t\t\t},\r\n\t\r\n\t\t\tgetMinMaxCoord: function( dim, parent, MinMax ) { // used for getting the dimensions of the tree, dim = 'X' || 'Y'\r\n\t\t\t\t// looks for min and max (X and Y) within the set of nodes\r\n\t\t\t\tparent = parent || this.get(0);\r\n\t\r\n\t\t\t\tMinMax = MinMax || { // start with root node dimensions\r\n\t\t\t\t\t\tmin: parent[dim],\r\n\t\t\t\t\t\tmax: parent[dim] + ( ( dim == 'X' )? parent.width: parent.height )\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\tvar i = parent.childrenCount();\r\n\t\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tvar node = parent.childAt( i ),\r\n\t\t\t\t\t\tmaxTest = node[dim] + ( ( dim == 'X' )? node.width: node.height ),\r\n\t\t\t\t\t\tminTest = node[dim];\r\n\t\r\n\t\t\t\t\tif ( maxTest > MinMax.max ) {\r\n\t\t\t\t\t\tMinMax.max = maxTest;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( minTest < MinMax.min ) {\r\n\t\t\t\t\t\tMinMax.min = minTest;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.getMinMaxCoord( dim, node, MinMax );\r\n\t\t\t\t}\r\n\t\t\t\treturn MinMax;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {object} nodeStructure\r\n\t\t\t * @returns {boolean}\r\n\t\t\t */\r\n\t\t\thasGrandChildren: function( nodeStructure ) {\r\n\t\t\t\tvar i = nodeStructure.children.length;\r\n\t\t\t\twhile ( i-- ) {\r\n\t\t\t\t\tif ( nodeStructure.children[i].children ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * TreeNode constructor.\r\n\t\t * @param {object} nodeStructure\r\n\t\t * @param {number} id\r\n\t\t * @param {number} parentId\r\n\t\t * @param {Tree} tree\r\n\t\t * @param {number} stackParentId\r\n\t\t * @constructor\r\n\t\t */\r\n\t\tvar TreeNode = function( nodeStructure, id, parentId, tree, stackParentId, level ) {\r\n\t\t\tthis.reset( nodeStructure, id, parentId, tree, stackParentId, level );\r\n\t\t};\r\n\t\r\n\t\tTreeNode.prototype = {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {object} nodeStructure\r\n\t\t\t * @param {number} id\r\n\t\t\t * @param {number} parentId\r\n\t\t\t * @param {Tree} tree\r\n\t\t\t * @param {number} stackParentId\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\treset: function( nodeStructure, id, parentId, tree, stackParentId, level ) {\r\n\t\t\t\tthis.id = id;\r\n\t\t\t\tthis.parentId = parentId;\r\n\t\t\t\tthis.level = level;\r\n\t\t\t\tthis.treeId = tree.id;\r\n\t\t\t\t// this.tree = tree;//???\r\n\t\r\n\t\t\t\tthis.prelim = 0;\r\n\t\t\t\tthis.modifier = 0;\r\n\t\t\t\tthis.leftNeighborId = null;\r\n\t\r\n\t\t\t\tthis.stackParentId = stackParentId;\r\n\t\r\n\t\t\t\t// pseudo node is a node with width=height=0, it is invisible, but necessary for the correct positioning of the tree\r\n\t\t\t\tthis.pseudo = nodeStructure === 'pseudo' || nodeStructure['pseudo']; // todo: surely if nodeStructure is a scalar then the rest will error:\r\n\t\r\n\t\t\t\tthis.nodeStructure = nodeStructure;//ref to the original data structure\r\n\t\r\n\t\t\t\tthis.meta = nodeStructure.meta || {};\r\n\t\t\t\tthis.image = nodeStructure.image || null;\r\n\t\r\n\t\t\t\tthis.link = UTIL.createMerge( tree.CONFIG.node.link,  nodeStructure.link );\r\n\t\r\n\t\t\t\tthis.connStyle = UTIL.createMerge( tree.CONFIG.connectors, nodeStructure.connectors );\r\n\t\t\t\tthis.connector = null;\r\n\t\r\n\t\t\t\tthis.drawLineThrough = nodeStructure.drawLineThrough === false ? false : ( nodeStructure.drawLineThrough || tree.CONFIG.node.drawLineThrough );\r\n\t\r\n\t\t\t\tthis.collapsable = nodeStructure.collapsable === false ? false : ( nodeStructure.collapsable || tree.CONFIG.node.collapsable );\r\n\t\t\t\tthis.collapsed = nodeStructure.collapsed;\r\n\t\r\n\t\t\t\t//\r\n\t\t\t\tvar textPropertyName = tree.CONFIG.text || 'text';//can config the text property name\r\n\t\t\t\tthis.text = nodeStructure[textPropertyName];//.text\r\n\t\r\n\t\t\t\t// '.node' DIV\r\n\t\t\t\tthis.nodeInnerHTML = nodeStructure.innerHTML;\r\n\t\t\t\tthis.nodeHTMLclass = (tree.CONFIG.node.HTMLclass ? tree.CONFIG.node.HTMLclass : '') + // globally defined class for the nodex\r\n\t\t\t\t\t(nodeStructure.HTMLclass ? (' ' + nodeStructure.HTMLclass) : '');\t\t// + specific node class\r\n\t\r\n\t\t\t\tthis.nodeHTMLid = nodeStructure.HTMLid;\r\n\t\r\n\t\t\t\tthis.children = [];\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tgetTree: function() {\r\n\t\t\t\treturn TreeStore.get( this.treeId );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {object}\r\n\t\t\t */\r\n\t\t\tgetTreeConfig: function() {\r\n\t\t\t\treturn this.getTree().CONFIG;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {NodeDB}\r\n\t\t\t */\r\n\t\t\tgetTreeNodeDb: function() {\r\n\t\t\t\treturn this.getTree().getNodeDb();\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {number} nodeId\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tlookupNode: function( nodeId ) {\r\n\t\t\t\treturn this.getTreeNodeDb().get( nodeId );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {Tree}\r\n\t\t\t */\r\n\t\t\tTree: function() {\r\n\t\t\t\treturn TreeStore.get( this.treeId );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {number} nodeId\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tdbGet: function( nodeId ) {\r\n\t\t\t\treturn this.getTreeNodeDb().get( nodeId );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Returns the width of the node\r\n\t\t\t * @returns {float}\r\n\t\t\t */\r\n\t\t\tsize: function() {\r\n\t\t\t\tvar orientation = this.getTreeConfig().rootOrientation;\r\n\t\r\n\t\t\t\tif ( this.pseudo ) {\r\n\t\t\t\t\t// prevents separating the subtrees\r\n\t\t\t\t\treturn ( -this.getTreeConfig().subTeeSeparation );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( orientation == 'NORTH' || orientation == 'SOUTH' ) {\r\n\t\t\t\t\treturn this.width;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( orientation == 'WEST' || orientation == 'EAST' ) {\r\n\t\t\t\t\treturn this.height;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {number}\r\n\t\t\t */\r\n\t\t\tchildrenCount: function () {\r\n\t\t\t\treturn ( ( this.collapsed || !this.children)? 0: this.children.length );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {number} index\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tchildAt: function( index ) {\r\n\t\t\t\treturn this.dbGet( this.children[index] );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tfirstChild: function() {\r\n\t\t\t\treturn this.childAt( 0 );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tlastChild: function() {\r\n\t\t\t\treturn this.childAt( this.children.length - 1 );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tparent: function() {\r\n\t\t\t\treturn this.lookupNode( this.parentId );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tleftNeighbor: function() {\r\n\t\t\t\tif ( this.leftNeighborId ) {\r\n\t\t\t\t\treturn this.lookupNode( this.leftNeighborId );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\trightNeighbor: function() {\r\n\t\t\t\tif ( this.rightNeighborId ) {\r\n\t\t\t\t\treturn this.lookupNode( this.rightNeighborId );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tleftSibling: function () {\r\n\t\t\t\tvar leftNeighbor = this.leftNeighbor();\r\n\t\r\n\t\t\t\tif ( leftNeighbor && leftNeighbor.parentId == this.parentId ){\r\n\t\t\t\t\treturn leftNeighbor;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\trightSibling: function () {\r\n\t\t\t\tvar rightNeighbor = this.rightNeighbor();\r\n\t\r\n\t\t\t\tif ( rightNeighbor && rightNeighbor.parentId == this.parentId ) {\r\n\t\t\t\t\treturn rightNeighbor;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {number}\r\n\t\t\t */\r\n\t\t\tchildrenCenter: function () {\r\n\t\t\t\tvar first = this.firstChild(),\r\n\t\t\t\t\tlast = this.lastChild();\r\n\t\r\n\t\t\t\treturn ( first.prelim + ((last.prelim - first.prelim) + last.size()) / 2 );\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Find out if one of the node ancestors is collapsed\r\n\t\t\t * @returns {*}\r\n\t\t\t */\r\n\t\t\tcollapsedParent: function() {\r\n\t\t\t\tvar parent = this.parent();\r\n\t\t\t\tif ( !parent ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif ( parent.collapsed ) {\r\n\t\t\t\t\treturn parent;\r\n\t\t\t\t}\r\n\t\t\t\treturn parent.collapsedParent();\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * Returns the leftmost child at specific level, (initial level = 0)\r\n\t\t\t * @param level\r\n\t\t\t * @param depth\r\n\t\t\t * @returns {*}\r\n\t\t\t */\r\n\t\t\tleftMost: function ( level, depth ) {\r\n\t\t\t\tif ( level >= depth ) {\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t\tif ( this.childrenCount() === 0 ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = this.childrenCount(); i < n; i++ ) {\r\n\t\t\t\t\tvar leftmostDescendant = this.childAt( i ).leftMost( level + 1, depth );\r\n\t\t\t\t\tif ( leftmostDescendant ) {\r\n\t\t\t\t\t\treturn leftmostDescendant;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\t// returns start or the end point of the connector line, origin is upper-left\r\n\t\t\tconnectorPoint: function(startPoint) {\r\n\t\t\t\tvar orient = this.Tree().CONFIG.rootOrientation, point = {};\r\n\t\r\n\t\t\t\tif ( this.stackParentId ) { // return different end point if node is a stacked child\r\n\t\t\t\t\tif ( orient == 'NORTH' || orient == 'SOUTH' ) {\r\n\t\t\t\t\t\torient = 'WEST';\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( orient == 'EAST' || orient == 'WEST' ) {\r\n\t\t\t\t\t\torient = 'NORTH';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// if pseudo, a virtual center is used\r\n\t\t\t\tif ( orient == 'NORTH' ) {\r\n\t\t\t\t\tpoint.x = (this.pseudo) ? this.X - this.Tree().CONFIG.subTeeSeparation/2 : this.X + this.width/2;\r\n\t\t\t\t\tpoint.y = (startPoint) ? this.Y + this.height : this.Y;\r\n\t\t\t\t}\r\n\t\t\t\telse if (orient == 'SOUTH') {\r\n\t\t\t\t\tpoint.x = (this.pseudo) ? this.X - this.Tree().CONFIG.subTeeSeparation/2 : this.X + this.width/2;\r\n\t\t\t\t\tpoint.y = (startPoint) ? this.Y : this.Y + this.height;\r\n\t\t\t\t}\r\n\t\t\t\telse if (orient == 'EAST') {\r\n\t\t\t\t\tpoint.x = (startPoint) ? this.X : this.X + this.width;\r\n\t\t\t\t\tpoint.y = (this.pseudo) ? this.Y - this.Tree().CONFIG.subTeeSeparation/2 : this.Y + this.height/2;\r\n\t\t\t\t}\r\n\t\t\t\telse if (orient == 'WEST') {\r\n\t\t\t\t\tpoint.x = (startPoint) ? this.X + this.width : this.X;\r\n\t\t\t\t\tpoint.y =  (this.pseudo) ? this.Y - this.Tree().CONFIG.subTeeSeparation/2 : this.Y + this.height/2;\r\n\t\t\t\t}\r\n\t\t\t\treturn point;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {string}\r\n\t\t\t */\r\n\t\t\tpathStringThrough: function() { // get the geometry of a path going through the node\r\n\t\t\t\tvar startPoint = this.connectorPoint( true ),\r\n\t\t\t\t\tendPoint = this.connectorPoint( false );\r\n\t\r\n\t\t\t\treturn [\"M\", startPoint.x+\",\"+startPoint.y, 'L', endPoint.x+\",\"+endPoint.y].join(\" \");\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @param {object} hidePoint\r\n\t\t\t */\r\n\t\t\tdrawLineThroughMe: function( hidePoint ) { // hidepoint se proslijedjuje ako je node sakriven zbog collapsed\r\n\t\t\t\tvar pathString = hidePoint?\r\n\t\t\t\t\tthis.Tree().getPointPathString( hidePoint ):\r\n\t\t\t\t\tthis.pathStringThrough();\r\n\t\r\n\t\t\t\tthis.lineThroughMe = this.lineThroughMe || this.Tree()._R.path(pathString);\r\n\t\r\n\t\t\t\tvar line_style = UTIL.cloneObj( this.connStyle.style );\r\n\t\r\n\t\t\t\tdelete line_style['arrow-start'];\r\n\t\t\t\tdelete line_style['arrow-end'];\r\n\t\r\n\t\t\t\tthis.lineThroughMe.attr( line_style );\r\n\t\r\n\t\t\t\tif ( hidePoint ) {\r\n\t\t\t\t\tthis.lineThroughMe.hide();\r\n\t\t\t\t\tthis.lineThroughMe.hidden = true;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\taddSwitchEvent: function( nodeSwitch ) {\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tUTIL.addEvent( nodeSwitch, 'click',\r\n\t\t\t\t\tfunction( e ) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\tif ( self.getTreeConfig().callback.onBeforeClickCollapseSwitch.apply( self, [ nodeSwitch, e ] ) === false ) {\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tself.toggleCollapse();\r\n\t\r\n\t\t\t\t\t\tself.getTreeConfig().callback.onAfterClickCollapseSwitch.apply( self, [ nodeSwitch, e ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tcollapse: function() {\r\n\t\t\t\tif ( !this.collapsed ) {\r\n\t\t\t\t\tthis.toggleCollapse();\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\texpand: function() {\r\n\t\t\t\tif ( this.collapsed ) {\r\n\t\t\t\t\tthis.toggleCollapse();\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\ttoggleCollapse: function() {\r\n\t\t\t\tvar oTree = this.getTree();\r\n\t\r\n\t\t\t\tif ( !oTree.inAnimation ) {\r\n\t\t\t\t\toTree.inAnimation = true;\r\n\t\r\n\t\t\t\t\tthis.collapsed = !this.collapsed; // toggle the collapse at each click\r\n\t\t\t\t\tUTIL.toggleClass( this.nodeDOM, 'collapsed', this.collapsed );\r\n\t\r\n\t\t\t\t\toTree.positionTree();\r\n\t\r\n\t\t\t\t\tvar self = this;\r\n\t\r\n\t\t\t\t\tsetTimeout(\r\n\t\t\t\t\t\tfunction() { // set the flag after the animation\r\n\t\t\t\t\t\t\toTree.inAnimation = false;\r\n\t\t\t\t\t\t\toTree.CONFIG.callback.onToggleCollapseFinished.apply( oTree, [ self, self.collapsed ] );\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t( oTree.CONFIG.animation.nodeSpeed > oTree.CONFIG.animation.connectorsSpeed )?\r\n\t\t\t\t\t\t\toTree.CONFIG.animation.nodeSpeed:\r\n\t\t\t\t\t\t\toTree.CONFIG.animation.connectorsSpeed\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\thide: function( collapse_to_point ) {\r\n\t\t\t\tcollapse_to_point = collapse_to_point || false;\r\n\t\r\n\t\t\t\tvar bCurrentState = this.hidden;\r\n\t\t\t\tthis.hidden = true;\r\n\t\r\n\t\t\t\tthis.nodeDOM.style.overflow = 'hidden';\r\n\t\r\n\t\t\t\tvar tree = this.getTree(),\r\n\t\t\t\t\tconfig = this.getTreeConfig(),\r\n\t\t\t\t\toNewState = {\r\n\t\t\t\t\t\topacity: 0\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\tif ( collapse_to_point ) {\r\n\t\t\t\t\toNewState.left = collapse_to_point.x;\r\n\t\t\t\t\toNewState.top = collapse_to_point.y;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// if parent was hidden in initial configuration, position the node behind the parent without animations\r\n\t\t\t\tif ( !this.positioned || bCurrentState ) {\r\n\t\t\t\t\tthis.nodeDOM.style.visibility = 'hidden';\r\n\t\t\t\t\tif ( $ ) {\r\n\t\t\t\t\t\t$( this.nodeDOM ).css( oNewState );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.nodeDOM.style.left = oNewState.left + 'px';\r\n\t\t\t\t\t\tthis.nodeDOM.style.top = oNewState.top + 'px';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.positioned = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// todo: fix flashy bug when a node is manually hidden and tree.redraw is called.\r\n\t\t\t\t\tif ( $ ) {\r\n\t\t\t\t\t\t$( this.nodeDOM ).animate(\r\n\t\t\t\t\t\t\toNewState, config.animation.nodeSpeed, config.animation.nodeAnimation,\r\n\t\t\t\t\t\t\tfunction () {\r\n\t\t\t\t\t\t\t\tthis.style.visibility = 'hidden';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.nodeDOM.style.transition = 'all '+config.animation.nodeSpeed+'ms ease';\r\n\t\t\t\t\t\tthis.nodeDOM.style.transitionProperty = 'opacity, left, top';\r\n\t\t\t\t\t\tthis.nodeDOM.style.opacity = oNewState.opacity;\r\n\t\t\t\t\t\tthis.nodeDOM.style.left = oNewState.left + 'px';\r\n\t\t\t\t\t\tthis.nodeDOM.style.top = oNewState.top + 'px';\r\n\t\t\t\t\t\tthis.nodeDOM.style.visibility = 'hidden';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// animate the line through node if the line exists\r\n\t\t\t\tif ( this.lineThroughMe ) {\r\n\t\t\t\t\tvar new_path = tree.getPointPathString( collapse_to_point );\r\n\t\t\t\t\tif ( bCurrentState ) {\r\n\t\t\t\t\t\t// update without animations\r\n\t\t\t\t\t\tthis.lineThroughMe.attr( { path: new_path } );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// update with animations\r\n\t\t\t\t\t\ttree.animatePath( this.lineThroughMe, tree.getPointPathString( collapse_to_point ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\thideConnector: function() {\r\n\t\t\t\tvar oTree = this.Tree();\r\n\t\t\t\tvar oPath = oTree.connectionStore[this.id];\r\n\t\t\t\tif ( oPath ) {\r\n\t\t\t\t\toPath.animate(\r\n\t\t\t\t\t\t{ 'opacity': 0 },\r\n\t\t\t\t\t\toTree.CONFIG.animation.connectorsSpeed,\r\n\t\t\t\t\t\toTree.CONFIG.animation.connectorsAnimation\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\tshow: function() {\r\n\t\t\t\tvar bCurrentState = this.hidden;\r\n\t\t\t\tthis.hidden = false;\r\n\t\r\n\t\t\t\tthis.nodeDOM.style.visibility = 'visible';\r\n\t\r\n\t\t\t\tvar oTree = this.Tree();\r\n\t\r\n\t\t\t\tvar oNewState = {\r\n\t\t\t\t\t\tleft: this.X,\r\n\t\t\t\t\t\ttop: this.Y,\r\n\t\t\t\t\t\topacity: 1\r\n\t\t\t\t\t},\r\n\t\t\t\t\tconfig = this.getTreeConfig();\r\n\t\r\n\t\t\t\t// if the node was hidden, update opacity and position\r\n\t\t\t\tif ( $ ) {\r\n\t\t\t\t\t$( this.nodeDOM ).animate(\r\n\t\t\t\t\t\toNewState,\r\n\t\t\t\t\t\tconfig.animation.nodeSpeed, config.animation.nodeAnimation,\r\n\t\t\t\t\t\tfunction () {\r\n\t\t\t\t\t\t\t// $.animate applies \"overflow:hidden\" to the node, remove it to avoid visual problems\r\n\t\t\t\t\t\t\tthis.style.overflow = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.nodeDOM.style.transition = 'all '+config.animation.nodeSpeed+'ms ease';\r\n\t\t\t\t\tthis.nodeDOM.style.transitionProperty = 'opacity, left, top';\r\n\t\t\t\t\tthis.nodeDOM.style.left = oNewState.left + 'px';\r\n\t\t\t\t\tthis.nodeDOM.style.top = oNewState.top + 'px';\r\n\t\t\t\t\tthis.nodeDOM.style.opacity = oNewState.opacity;\r\n\t\t\t\t\tthis.nodeDOM.style.overflow = '';\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( this.lineThroughMe ) {\r\n\t\t\t\t\tthis.getTree().animatePath( this.lineThroughMe, this.pathStringThrough() );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\t\r\n\t\t\t/**\r\n\t\t\t * @returns {TreeNode}\r\n\t\t\t */\r\n\t\t\tshowConnector: function() {\r\n\t\t\t\tvar oTree = this.Tree();\r\n\t\t\t\tvar oPath = oTree.connectionStore[this.id];\r\n\t\t\t\tif ( oPath ) {\r\n\t\t\t\t\toPath.animate(\r\n\t\t\t\t\t\t{ 'opacity': 1 },\r\n\t\t\t\t\t\toTree.CONFIG.animation.connectorsSpeed,\r\n\t\t\t\t\t\toTree.CONFIG.animation.connectorsAnimation\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\r\n\t\t/**\r\n\t\t * Build a node from the 'text' and 'img' property and return with it.\r\n\t\t *\r\n\t\t * The node will contain all the fields that present under the 'text' property\r\n\t\t * Each field will refer to a css class with name defined as node-{$property_name}\r\n\t\t *\r\n\t\t * Example:\r\n\t\t * The definition:\r\n\t\t *\r\n\t\t *   text: {\r\n\t\t *     desc: \"some description\",\r\n\t\t *     paragraph: \"some text\"\r\n\t\t *   }\r\n\t\t *\r\n\t\t * will generate the following elements:\r\n\t\t *\r\n\t\t *   <p class=\"node-desc\">some description</p>\r\n\t\t *   <p class=\"node-paragraph\">some text</p>\r\n\t\t *\r\n\t\t * @Returns the configured node\r\n\t\t */\r\n\t\tTreeNode.prototype.buildNodeFromText = function (node, tree) {\r\n\t\r\n\t\t\tif(tree.CONFIG.callback.buildNodeFromText){\r\n\t\t\t\tvar ele = tree.CONFIG.callback.buildNodeFromText.apply(this, [this.nodeStructure, node]);\r\n\t\t\t\tif(ele){\r\n\t\t\t\t\tnode.appendChild(ele);\r\n\t\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t// IMAGE\r\n\t\t\tif (this.image) {\r\n\t\t\t\timage = document.createElement('img');\r\n\t\t\t\timage.src = this.image;\r\n\t\t\t\tnode.appendChild(image);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// TEXT\r\n\t\t\tif (this.text) {\r\n\t\t\t\tvar text = this.text;\r\n\t\r\n\t\t\t\t//text may be string\r\n\t\t\t\tif(typeof text == 'string'){\r\n\t\t\t\t\tvar textElement = document.createElement(text[key].href ? 'a' : 'p');\r\n\t\t\t\t\ttextElement.appendChild(document.createTextNode(text));\r\n\t\t\t\t\tnode.appendChild(textElement);\r\n\t\t\t\t}\r\n\t\t\t\telse{//list all properties in the text object\r\n\t\t\t\t\tfor (var key in text) {\r\n\t\t\t\t\t\t// adding DATA Attributes to the node\r\n\t\t\t\t\t\tif (key.startsWith(\"data-\")) {\r\n\t\t\t\t\t\t\tnode.setAttribute(key, text[key]);\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar textElement = document.createElement(text[key].href ? 'a' : 'p');\r\n\t\r\n\t\t\t\t\t\t// make an <a> element if required\r\n\t\t\t\t\t\tif (text[key].href) {\r\n\t\t\t\t\t\t\ttextElement.href = text[key].href;\r\n\t\t\t\t\t\t\tif (text[key].target) {\r\n\t\t\t\t\t\t\t\ttextElement.target = text[key].target;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttextElement.className =  \"node-\"+key;\r\n\t\t\t\t\t\ttextElement.appendChild(document.createTextNode(\r\n\t\t\t\t\t\t\ttext[key].val ? text[key].val :\r\n\t\t\t\t\t\t\t\ttext[key] instanceof Object ? \"'val' param missing!\" : text[key]\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\tnode.appendChild(textElement);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn node;\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Build a node from  'nodeInnerHTML' property that defines an existing HTML element, referenced by it's id, e.g: #someElement\r\n\t\t * Change the text in the passed node to 'Wrong ID selector' if the referenced element does ot exist,\r\n\t\t * return with a cloned and configured node otherwise\r\n\t\t *\r\n\t\t * @Returns node the configured node\r\n\t\t */\r\n\t\tTreeNode.prototype.buildNodeFromHtml = function(node) {\r\n\t\t\t// get some element by ID and clone its structure into a node\r\n\t\t\tif (this.nodeInnerHTML.charAt(0) === \"#\") {\r\n\t\t\t\tvar elem = document.getElementById(this.nodeInnerHTML.substring(1));\r\n\t\t\t\tif (elem) {\r\n\t\t\t\t\tnode = elem.cloneNode(true);\r\n\t\t\t\t\tnode.id += \"-clone\";\r\n\t\t\t\t\tnode.className += \" node\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnode.innerHTML = \"<b> Wrong ID selector </b>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// insert your custom HTML into a node\r\n\t\t\t\tnode.innerHTML = this.nodeInnerHTML;\r\n\t\t\t}\r\n\t\t\treturn node;\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * @param {Tree} tree\r\n\t\t */\r\n\t\tTreeNode.prototype.createGeometry = function( tree ) {\r\n\t\t\tif ( this.id === 0 && tree.CONFIG.hideRootNode ) {\r\n\t\t\t\tthis.width = 0;\r\n\t\t\t\tthis.height = 0;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar drawArea = tree.drawArea,\r\n\t\t\t\timage,\r\n\t\t\t\tself = this,\r\n\t\r\n\t\t\t\t/////////// CREATE NODE //////////////\r\n\t\t\t\tnode = document.createElement( this.link.href? 'a': 'div' );\r\n\r\n\t\t\tUTIL.addEvent(node, 'click', function(){\r\n\t\t\t\ttree.CONFIG.callback.onClickNode.apply(node, [self, tree]);\r\n\t\t\t})\r\n\r\n\t\t\tnode.className = ( !this.pseudo )? TreeNode.CONFIG.nodeHTMLclass: 'pseudo';\r\n\t\t\tif ( this.nodeHTMLclass && !this.pseudo ) {\r\n\t\t\t\tnode.className += ' ' + this.nodeHTMLclass;\r\n\t\t\t}\r\n\t\r\n\t\t\tif(TreeNode.CONFIG.nodeHTMLclass){\r\n\t\t\t\tvar levelClassName = TreeNode.CONFIG.nodeHTMLclass.split(' ')[0] +'-' + this.level\r\n\t\t\t\tnode.className += ' ' + levelClassName; \r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.nodeHTMLid ) {\r\n\t\t\t\tnode.id = this.nodeHTMLid;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.link.href ) {\r\n\t\t\t\tnode.href = this.link.href;\r\n\t\t\t\tnode.target = this.link.target;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( $ ) {\r\n\t\t\t\t$( node ).data( 'treenode', this );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tnode.data = {\r\n\t\t\t\t\t'treenode': this\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\r\n\t\t\t/////////// BUILD NODE CONTENT //////////////\r\n\t\t\tif ( !this.pseudo ) {\r\n\t\t\t\tnode = this.nodeInnerHTML? this.buildNodeFromHtml(node, tree) : this.buildNodeFromText(node, tree)\r\n\t\r\n\t\t\t\t// handle collapse switch\r\n\t\t\t\tif ( this.collapsed || (this.collapsable && this.childrenCount() && !this.stackParentId) ) {\r\n\t\t\t\t\tthis.createSwitchGeometry( tree, node );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\ttree.CONFIG.callback.onCreateNode.apply( tree, [this, node] );\r\n\t\r\n\t\t\t/////////// APPEND all //////////////\r\n\t\t\tdrawArea.appendChild(node);\r\n\t\r\n\t\t\tthis.width = node.offsetWidth;\r\n\t\t\tthis.height = node.offsetHeight;\r\n\t\r\n\t\t\tthis.nodeDOM = node;\r\n\t\r\n\t\t\ttree.imageLoader.processNode(this);\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * @param {Tree} tree\r\n\t\t * @param {Element} nodeEl\r\n\t\t */\r\n\t\tTreeNode.prototype.createSwitchGeometry = function( tree, nodeEl ) {\r\n\t\t\tnodeEl = nodeEl || this.nodeDOM;\r\n\t\r\n\t\t\t// safe guard and check to see if it has a collapse switch\r\n\t\t\tvar nodeSwitchEl = UTIL.findEl( '.collapse-switch', true, nodeEl );\r\n\t\t\tif ( !nodeSwitchEl ) {\r\n\t\t\t\tnodeSwitchEl = document.createElement( 'a' );\r\n\t\t\t\tnodeSwitchEl.className = \"collapse-switch\";\r\n\t\r\n\t\t\t\tnodeEl.appendChild( nodeSwitchEl );\r\n\t\t\t\tthis.addSwitchEvent( nodeSwitchEl );\r\n\t\t\t\tif ( this.collapsed ) {\r\n\t\t\t\t\tnodeEl.className += \" collapsed\";\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttree.CONFIG.callback.onCreateNodeCollapseSwitch.apply( tree, [this, nodeEl, nodeSwitchEl] );\r\n\t\t\t}\r\n\t\t\treturn nodeSwitchEl;\r\n\t\t};\r\n\t\r\n\t\r\n\t\t// ###########################################\r\n\t\t//\t\tExpose global + default CONFIG params\r\n\t\t// ###########################################\r\n\t\r\n\t\r\n\t\tTree.CONFIG = {\r\n\t\t\tmaxDepth: 100,\r\n\t\t\trootOrientation: 'NORTH', // NORTH || EAST || WEST || SOUTH\r\n\t\t\tnodeAlign: 'CENTER', // CENTER || TOP || BOTTOM\r\n\t\t\tlevelSeparation: 30,\r\n\t\t\tsiblingSeparation: 30,\r\n\t\t\tsubTeeSeparation: 30,\r\n\t\r\n\t\t\thideRootNode: false,\r\n\t\r\n\t\t\tanimateOnInit: false,\r\n\t\t\tanimateOnInitDelay: 500,\r\n\t\r\n\t\t\tpadding: 15, // the difference is seen only when the scrollbar is shown\r\n\t\t\tscrollbar: 'native', // \"native\" || \"fancy\" || \"None\" (PS: \"fancy\" requires jquery and perfect-scrollbar)\r\n\t\r\n\t\t\ttext:'text',// text property name\r\n\t\r\n\t\t\tconnectors: {\r\n\t\t\t\ttype: 'curve', // 'curve' || 'step' || 'straight' || 'bCurve'\r\n\t\t\t\tstyle: {\r\n\t\t\t\t\tstroke: 'black'\r\n\t\t\t\t},\r\n\t\t\t\tstackIndent: 15\r\n\t\t\t},\r\n\t\r\n\t\t\tnode: { // each node inherits this, it can all be overridden in node config\r\n\t\r\n\t\t\t\t// HTMLclass: 'node',\r\n\t\t\t\t// drawLineThrough: false,\r\n\t\t\t\t// collapsable: false,\r\n\t\t\t\tlink: {\r\n\t\t\t\t\ttarget: '_self'\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tanimation: { // each node inherits this, it can all be overridden in node config\r\n\t\t\t\tnodeSpeed: 450,\r\n\t\t\t\tnodeAnimation: 'linear',\r\n\t\t\t\tconnectorsSpeed: 450,\r\n\t\t\t\tconnectorsAnimation: 'linear'\r\n\t\t\t},\r\n\t\r\n\t\t\tcallback: {\r\n\t\t\t\tonClickNode:function(treeNode, tree){},//this = node html\r\n\t\t\t\tbuildNodeFromText:function(nodeStructure, container){}, //this = treeNode\r\n\t\t\t\tonBeforeCreateNode:function(nodeStructure){},//this = Tree\r\n\t\t\t\tonCreateNode: function( treeNode, treeNodeDom ) {}, // this = Tree\r\n\t\t\t\tonCreateNodeCollapseSwitch: function( treeNode, treeNodeDom, switchDom ) {}, // this = Tree\r\n\t\t\t\tonAfterAddNode: function( newTreeNode, parentTreeNode, nodeStructure ) {}, // this = Tree\r\n\t\t\t\tonBeforeAddNode: function( parentTreeNode, nodeStructure ) {}, // this = Tree\r\n\t\t\t\tonAfterPositionNode: function( treeNode, nodeDbIndex, containerCenter, treeCenter) {}, // this = Tree\r\n\t\t\t\tonBeforePositionNode: function( treeNode, nodeDbIndex, containerCenter, treeCenter) {}, // this = Tree\r\n\t\t\t\tonToggleCollapseFinished: function ( treeNode, bIsCollapsed ) {}, // this = Tree\r\n\t\t\t\tonAfterClickCollapseSwitch: function( nodeSwitch, event ) {}, // this = TreeNode\r\n\t\t\t\tonBeforeClickCollapseSwitch: function( nodeSwitch, event ) {}, // this = TreeNode\r\n\t\t\t\tonTreeLoaded: function( rootTreeNode ) {} // this = Tree\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tTreeNode.CONFIG = {\r\n\t\t\tnodeHTMLclass: 'node'\r\n\t\t};\r\n\t\r\n\t\t// #############################################\r\n\t\t// Makes a JSON chart config out of Array config\r\n\t\t// #############################################\r\n\t\r\n\t\tvar JSONconfig = {\r\n\t\t\tmake: function( configArray ) {\r\n\t\r\n\t\t\t\tvar i = configArray.length, node;\r\n\t\r\n\t\t\t\tthis.jsonStructure = {\r\n\t\t\t\t\tchart: null,\r\n\t\t\t\t\tnodeStructure: null\r\n\t\t\t\t};\r\n\t\t\t\t//fist loop: find config, find root;\r\n\t\t\t\twhile(i--) {\r\n\t\t\t\t\tnode = configArray[i];\r\n\t\t\t\t\tif (node.hasOwnProperty('container')) {\r\n\t\t\t\t\t\tthis.jsonStructure.chart = node;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif (!node.hasOwnProperty('parent') && ! node.hasOwnProperty('container')) {\r\n\t\t\t\t\t\tthis.jsonStructure.nodeStructure = node;\r\n\t\t\t\t\t\tnode._json_id = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.findChildren(configArray);\r\n\t\r\n\t\t\t\treturn this.jsonStructure;\r\n\t\t\t},\r\n\t\r\n\t\t\tfindChildren: function(nodes) {\r\n\t\t\t\tvar parents = [0]; // start with a a root node\r\n\t\r\n\t\t\t\twhile(parents.length) {\r\n\t\t\t\t\tvar parentId = parents.pop(),\r\n\t\t\t\t\t\tparent = this.findNode(this.jsonStructure.nodeStructure, parentId),\r\n\t\t\t\t\t\ti = 0, len = nodes.length,\r\n\t\t\t\t\t\tchildren = [];\r\n\t\r\n\t\t\t\t\tfor(;i<len;i++) {\r\n\t\t\t\t\t\tvar node = nodes[i];\r\n\t\t\t\t\t\tif(node.parent && (node.parent._json_id == parentId)) { // skip config and root nodes\r\n\t\r\n\t\t\t\t\t\t\tnode._json_id = this.getID();\r\n\t\r\n\t\t\t\t\t\t\tdelete node.parent;\r\n\t\r\n\t\t\t\t\t\t\tchildren.push(node);\r\n\t\t\t\t\t\t\tparents.push(node._json_id);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif (children.length) {\r\n\t\t\t\t\t\tparent.children = children;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tfindNode: function( node, nodeId ) {\r\n\t\t\t\tvar childrenLen, found;\r\n\t\r\n\t\t\t\tif (node._json_id === nodeId) {\r\n\t\t\t\t\treturn node;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( node.children ) {\r\n\t\t\t\t\tchildrenLen = node.children.length;\r\n\t\t\t\t\twhile ( childrenLen-- ) {\r\n\t\t\t\t\t\tfound = this.findNode(node.children[childrenLen], nodeId);\r\n\t\t\t\t\t\tif ( found ) {\r\n\t\t\t\t\t\t\treturn found;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tgetID: (\r\n\t\t\t\tfunction() {\r\n\t\t\t\t\tvar i = 1;\r\n\t\t\t\t\treturn function() {\r\n\t\t\t\t\t\treturn i++;\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t)()\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * Chart constructor.\r\n\t\t */\r\n\t\tvar Treant = function( jsonConfig, callback, jQuery ) {\r\n\t\t\tif ( jsonConfig instanceof Array ) {\r\n\t\t\t\tjsonConfig = JSONconfig.make( jsonConfig );\r\n\t\t\t}\r\n\t\r\n\t\t\t// optional\r\n\t\t\tif ( jQuery ) {\r\n\t\t\t\t$ = jQuery;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.tree = TreeStore.createTree( jsonConfig );\r\n\t\t\tthis.tree.positionTree( callback );\r\n\t\t};\r\n\t\r\n\t\tTreant.prototype.destroy = function() {\r\n\t\t\tTreeStore.destroy( this.tree.id );\r\n\t\t};\r\n\t\r\n\t\t/* expose constructor globally */\r\n\t\twindow.Treant = Treant;\r\n\t\r\n\t})();\r\n\t"]}